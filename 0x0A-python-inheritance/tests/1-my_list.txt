::::::::::::
Funcion
::::::::::::

Importacion del modulo:
::::::::::::::::::::::::::::::::::::

>>> MyList = __import__('1-my_list').MyList

:::::::::::::::::::::::::::::::::::: 

Pruebas:
:::::::::::::

1 - Agragando elementos a la lista

>>> pepe = MyList()
>>> pepe.append(1)
>>> pepe.append(10)
>>> pepe.append(2)
>>> pepe.append(4)

>>> print(pepe)
[1, 10, 2, 4]

>>> pepe.print_sorted()
[1, 2, 4, 10]

2- Se prueba la lista vacia.

>>> pepe = MyList()

>>> print(pepe)
[]

>>> pepe.print_sorted()
[]

3 - se prueba una lista negativa.

>>> pepe = MyList()

>>> pepe.append(0)

>>> pepe.append(-1)

>>> pepe.append(-672)

>>> pepe.append(-2)

>>> print(pepe)
[0, -1, -672, -2]

>>> pepe.print_sorted()
[-672, -2, -1, 0]

4 - Verificamos si mandamos NULL

>>> pepe = MyList()

>>> pepe.append(NULL)
Traceback (most recent call last):
...
NameError: name 'NULL' is not defined

5 - Verificamos si mandamos NaN

>>> pepe = MyList()

>>> pepe.append(NaN)
Traceback (most recent call last):
...
NameError: name 'NaN' is not defined

6 - Verificamos si mandamos None

>>> pepe = MyList()

>>> pepe.append(None)

>>> print(pepe)
[None]

>>> pepe.print_sorted()
[None]

7 - verificamos que pasa si madamos chars

>>> pepe = MyList(["p", "e", "p", "e"])

>>> print(pepe)
['p', 'e', 'p', 'e']

>>> pepe.print_sorted()
['e', 'e', 'p', 'p']

8 - verificamos que pasa si madamos una cadena

>>> pepe = MyList(["pepe"])

>>> print(pepe)
['pepe']

>>> pepe.print_sorted()
['pepe']

9 - Verificamos que pasa su mandamos floats

>>> pepe = MyList([88.6, 2.02, 3.06, 1.01])

>>> print(pepe)
[88.6, 2.02, 3.06, 1.01]

>>> pepe.print_sorted()
[1.01, 2.02, 3.06, 88.6]

10 - Verificamos que pasa si mandamos enteros con chars

>>> pepe = MyList([88, "z"])

>>> print(pepe)
[88, 'z']

>>> pepe.print_sorted()
Traceback (most recent call last):
...
TypeError: '<' not supported between instances of 'str' and 'int'

11 - Verificamos que pasa si mandamos un tipo de dato diferente

>>> pepe = MyList(45)
Traceback (most recent call last):
...
TypeError: 'int' object is not iterable

12 - Verificamos que pasa si mandamos un tipo de dato diferente

>>> pepe = MyList(True)
Traceback (most recent call last):
...
TypeError: 'bool' object is not iterable

13 - Instancia de lista de clasese

>>> pepe = MyList()

>>> isinstance(pepe, list)
True

13 - Instancia de tipo correcto

>>> pepe = MyList()

>>> type(pepe) == MyList
True

13 - MyList es una subclase de list

>>> issubclass(MyList, list)
True

14 - Pasando argumentos a print_sorted()

>>> pepe.print_sorted(10)
Traceback (most recent call last):
...
TypeError: print_sorted() takes 1 positional argument but 2 were given

15 - Llamar la funcion desde la clase

>>> MyList.print_sorted()
Traceback (most recent call last):
...
TypeError: print_sorted() missing 1 required positional argument: 'self'

16 - objetos no definidos

>>> pepa.print_sorted()
Traceback (most recent call last):
...
NameError: name 'pepa' is not defined

17 - llamar a print_sorted() desde un tipo que no es lista

>>> entero = 1

>>> type(entero)
<class 'int'>

>>> entero.print_sorted()
Traceback (most recent call last):
...
AttributeError: 'int' object has no attribute 'print_sorted'